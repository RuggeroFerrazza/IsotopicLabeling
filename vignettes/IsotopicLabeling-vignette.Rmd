---
title: "How to use the IsotopicLabeling R package"
author: "Ruggero Ferrazza"
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    theme: united
    toc: yes
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

# Introduction

The purpose of this document is to explain how to use the *IsotopicLabeling* R package to analyse isotopic patterns from mass spectrometric data.

A typical labeling experiment involves the use of substrates enriched in one stable isotope, such as ^2^H or ^13^C; for example, cell cultures can be fed with ^13^C-labeled glucose. Consequently, after the growth period, the metabolites coming from the enriched substrate will have incorporated the labeling isotope.

Since the isotopic patterns observed by mass spectrometry reflect the isotopic abundances of the elements making up the observed species, the amount of labeling can be assessed by their proper examination, and the *IsotopicLabeling* R package provides such a tool.

In the following, a step-by-step explanation on how to use the *IsotopicLabeling* package will be given by using an example data set; the involved functions will be properly intoduced and discussed.

# The MS data set

The *IsotopicLabeling* package requires the MS data to be in the form of a data frame where the first two columns represent the *m/z* and the retention time (RT) of the mass peaks, whereas the other columns contain the peak intensities or areas (one column for each sample).

Since a very popular R package for pre-processing MS data is *xcms*, the *IsotopicLabeling* R package can also accept input data as *xcmsSet* objects, which basically contain the peak intensities or areas associated to each of the processed samples, together with their average retention time and *m/z*. In this case, the function `table_xcms` is available for converting such objects to the required data frame.

The example data set that comes with the *IsotopicLabeling* package is easily accessible through the command
```
data("xcms_obj")
```

It is an *xcmsSet* object containing LC-MS data relative to lipid extracts obtained from ^13^C labeling experiments on 8 samples: 

- The first 4 samples come from unlabeled cell coltures (natural ^13^C abundance);
- In the last 4 samples the cells were grown in a substrate where the glucose was replaced by uniformly-labeled ^13^C glucose (99% ^13^C labeling). 

The conversion of this data set can be achieved through the command:

```
peak_table <- table_xcms(xcms_obj)
```

The result is a data frame with as many columns as the number of samples, plus the first two columns reserved for *m/z* and retention times (see the reference manual for more information); here are its first few rows:

```{r, results = "hide", echo = FALSE, message = FALSE, warning = FALSE}
library(IsotopicLabeling)
data("xcms_obj")
peak_table <- table_xcms(xcms_obj)
```
```{r, echo = FALSE}
head(peak_table, n=3)
```

Please not that it is not compulsory to pre-process the LC-MS data with *xcms*, since this data frame can be obtained in a number of other independent ways, such as by using proprietary software of the vendor of the MS instrument; the important thing is for the data frame to be properly formatted:

- its first column, named "mz", should contain the mass-to-charge ratios of the peaks;
- its second column, named "rt", should contain the average retention times of the peaks (in seconds);
- the other columns should be named after the samples (one column for sample), and contain peak intensities or areas.

# A compact way of processing the data

From the MS data set, the whole analysis of the isotopic patterns can be performed through the single, compact function `main_labeling`. Using the example data set, this becomes:
```
fitted_abundances <- main_labeling(peak_table, compound, labeling, mass_shift, RT, RT_shift, 
chrom_width, initial_abundance)
```

As explained in the reference manual, some input parameters have to be specified:

- **peak_table**, the data frame of experimental peak intensities or areas;
- **compound**, a character vector specifying the chemical formula of the compound of interest. A special notation should be used, whereby the character "X" is used for denoting the element with unknown isotopic distribution (to be fitted by the package). For example, the [PC 34:1 + H]^+^ adduct, with chemical formula C42H83NO8P, should be written as "X42H83NO8P" for ^13^C isotopic labeling experiments, and "C42X82HNO8P" for ^2^H isotopic labeling experiments, in this last case keeping in mind that one hydrogen atom comes from the solvent, and has therefore fixed natural abundance.

    Please remember that adduct ions should be specified, and not the neutral molecular species;

- **labeling**, a character specifying the labeling element. It can be either "H" or "C";
- **mass_shift**, the maximum mass shift between measured and true mass. In other words, the mass accuracy of the measurements;
- **RT**, the expected retention time of the compound of interest (in sec);
- **RT_shift**, the maximum time shift allowed of the peaks with respect to the expected retention time (in sec);
- **chrom_width**, an estimate of the chromatographic width of the peaks (in sec);
- **initial_abundance**, either NA, or a numeric vector of the same length as the number of samples, with the initial guesses on the isotopic abundance of the labeling isotope. If provided, numbers between 0 and 1.

Using the data set of the example, the following parameters should be entered for the [PC 32:2 + H]^+^ adduct:
```
fitted_abundances <- main_labeling(peak_table, compound="X40H77NO8P", labeling="C", 
mass_shift=0.05, RT=285, RT_shift=20, chrom_width=7, initial_abundance=NA)
```


The steps undertaken by the `main_labeling` function are detailed in the following sections; the output of the analysis is an object of the class labeling, basically a list containing the results of the analysis. 
```{r, results = "hide", echo = FALSE, message = FALSE, warning = FALSE}
fitted_abundances <- main_labeling(peak_table, compound="X40H77NO8P", labeling="C", mass_shift=0.05, RT=285, RT_shift=20, chrom_width=7, initial_abundance=NA)
```
```{r}
attributes(fitted_abundances)
```

The details of the output can be found on the reference manual.

# Understanding the IsotoicLabeling package: a block scheme of the processing steps
 
The IsotopicLabeling package is based on the fact that the isotopic patterns obtained by MS reflect the isotopic abundances of the elements making up the observed compounds. Over the years, a number of different algorithms have been developed to a-priori compute isotopic patterns, knowing the relative distributions of the isotopes of any element. 

The problem with isotopic labeling experiments, though, is the opposite: a labeling isotope is used, and its relative abundance within the compounds of interest has to be inferred. The IsotopicLabeling package proposes to achieve this by exploiting the hidden information contained in the isotopic patterns. As explained above, an easy way to get this is by using the `main_labeling` function, which is basically a merging of successive functions each performing a particular job. In particular, the main steps are:

1. Gather information about the isotopes and all the possible isotopogues arising due to the labeling;
2. Extract the isotopic patterns of the compound of interest from the experimental data;
3. Analyze the obtained patterns in order to find the isotopic distribution of the labeling element that best describes the patterns.

Although the `main_labeling` function can perform all these steps at once, it is also possible to run separate functions for each of them. In the following, for the sake of explanation the second route is covered, an the steps are detailed.

## Isotopes and Isotopologues

The first function run by `main_labeling` is `isotopic_information`, which aims at gathering important information that will be required by the other functions of the package. It requires as input values the compound of interest, together with the type of labeling; in the example of [PC 32:2 + H]^+^, this would be:
```
info <- isotopic_information(compound="X40H77NO8P", labeling="C")
```
As detailed in the reference manual, the output is a named list:
```{r, results = "hide", echo = FALSE, message = FALSE, warning = FALSE}
info <- isotopic_information(compound="X40H77NO8P", labeling="C")
```
```{r}
attributes(info)
```
In particular, "isotopes" is a table with the natural isotopic abundances of the elements present in the compound, with the two isotopes of the labeling element X being given NA values:
```{r}
info$isotopes
```

Another important object is the "target" vector, which contains the exact masses of all the possible isotopologues of the species of interest coming from the labeling isotope. In the example, the [PC 32:2 + H]^+^ adduct has 40 carbon atoms, and therefore the possible isotopologues coming from ^13^C span a 41 mass range: from the monoisotopic species, where all the C atoms are ^12^C, to the species where all the 40 C atoms are ^13^C. However, since the isotopic patterns also depend on the other elements making up the compound, the list of target isotopologues is extended of two *m/z* units beyond the maximum achievable, which is enough for small and medium-sized molecules such as lipids and metabolites. 

The naming of the masses follows this convention:

- **M+0** is the monoisotopic species, where all the atoms (including X) are the lighest isotopes; 
- in **M+1** one light isotope (either X or any other element) is replaced by its heaviest counterpart;
- in **M+2** there have been two replacements, and so forth.

The underlying assumption is that the MS resolution is not high enough to resolve the isotopic fine structure, and therefore the replacement of, say, ^1^H with ^2^H is indistinguishable from the replacement of ^12^C with ^13^C. This is true for most of the instruments currently used in LC-MS measurements.

## Extracting the Experimental Isotopic Patterns

The next step is to extract the isotopic patterns from the experimental data. To this aim, the `isotopic_pattern` function can be used. In the example of [PC 32:2 + H]^+^, it is used this way:

```
experimental_patterns <- isotopic_pattern(peak_table, info, mass_shift=0.05, RT=285, 
RT_shift=20, chrom_width=7)
```
Among the input parameters are the table of peak intensities or areas, together with the list produced during the previous step. In addition, other parameters have to be specified, which have already been discussed previously, and are also detailed in the reference manual.

The net result is a matrix of the extracted patterns, with the first two columns reserved for the exact *m/z* and the retention times of the extracted peaks:
```{r, results = "hide", echo = FALSE, message = FALSE, warning = FALSE}
experimental_patterns <- isotopic_pattern(peak_table, info, mass_shift=0.05, RT=285, 
RT_shift=20, chrom_width=7)
```
```{r}
head(experimental_patterns, n=3)
```

In summary, what this function does is the following: 

1. It finds and stores the indices of the peaks that are within the specified *m/z* and RT ranges. This for all the target masses of the info$target vector;
2. It considers the retention times of the identified indices, and compares them across isotopologues in order to group them: peaks that differ in RT within the specified chromatographic width are assumed to come from two isotopologues of the same species;
3. At this point, more groups may be left: those having less than two identified isotopologues are discarded. If still more than one group is left, the one is chosen with the smallest difference between true and expected RT.

The figure below provides a graphical example of the patterns extracted for [PC 32:2 + H]^+^ in two samples, the first (to the left) without labeling, and the second one (to the right) with 99% ^13^C labeling. 

![Figure 1](Figure_1.png)

In this simple case, it can be seen at a glance that in the second case there is a great deal of labeling, since the most intense signal is shifted 40 mass units upwards with respect to the monoisotopic peak, therefore indicating that the most abundant species is the one where all the 40 carbon atoms have been replaced by its heaviest isotope (the labeling isotope, ^13^C). It is now the job of the IsotopicLabeling package to provide a quantitative estimate of the relative distribution between isotopes ^12^C and ^13^C in each sample.

## Analyzing the experimental patterns

Once the experimental patterns are available, they have to be analyzed in order to get an estimate of the isotopic abundance of the labeling isotope. This can be achieved through the function `find_abundance`. In the example,
```
fitted_abundances <- find_abundance(patterns=experimental_patterns, info, initial_abundance=NA)
```
There are three input parameters: the matrix of experimental patterns, the list "info" coming from the `isotopic_information` function, and the estimated initial abundances (default value= NA).

What the function does is to take each of the patterns, and fit the best theoretical pattern that reproduces it by iteratively changing the relative abundance between the isotopes of element X (either C or H, depending on the labeling experiment).

The output is an object of the class `labeling`, a list containing the results:
```{r, results = "hide", echo = FALSE, message = FALSE, warning = FALSE}
fitted_abundances <- find_abundance(patterns=experimental_patterns, info, initial_abundance=NA)
```
```{r}
attributes(fitted_abundances)
```
The details of each object can be found in the reference manual. Briefly, the estimated abundances of the labeling isotope are contained in `Best_estimate`, as numbers between 0 and 1. The standard errors coming from the fitting procedure (via the `nls` function) are in `std_error`, whereas `dev_percent` contains the percentage deviations of the best fitted theoretical patterns to the provided experimental patterns. The *m/z* values of the peaks in the patterns are in `x_scale`, whereas in `y_exp` are their normalized intensities, and in `y_theor` are the intensities of the fitted theoretical patterns. In addition, the residuals can be found in `residuals`.

What the function performs can be summarized as follows:

- Each experimental pattern is taken and normalized so that its highest signal is set to 100;
- The position of the most intense signal is assessed and used to get a first rough estimate of the isotopic abundance of X;
- A fitting procedure ensues through the `nls` function, whereby the single unkwown variable "isotopic  abundance of X" is iteratively changed starting from its estimated value, and each time the resulting (normalized) theoretical patterns are compared to the experimental pattern. The value obtained from the fitting procedure is the one that minimizes the the sum of squares of the difference between observed and theoretical values. 

    In order to take noise into account, a weight is given to the signals, proportional to the square root of their intensities. 
    
    The theoretical patterns are built by making use of the `ecipex` R package, which computes them by exploiting Fourier transforms of simplex-based elemental models.


# Looking at the results

Following the analysis, the results contained in the object of class *labeling* have to be looked at. To this aim, the IsotopicLabeling package provides several alternatives:

1. It is possible to quickly glance at the estimated abundances by using the generic function `summary`. In the example:

    ```{r}
    summary(fitted_abundances)
    ```

    A table is produced with in its first row the estimated values, and in the second one the standard deviations of the estimates from the fitting procedure. In the example, it can be seen that the estimates for the unlabeled samples have an average value of 1.08% (close to the natural value of 1.07%), whereas for the labeled samples the average is 98.94%.
    
2. A series of plots can be produced with the generic function `plot`, to get the normalized experimental patterns superimposed to the best fitted theoretical patterns:
    ```
    plot(fitted_abundances, what="patterns")
    ```
    Two of the plots are reported here:
    
    ![Figure 2](Figure_2.png)
    
    
    ![Figure 3](Figure_3.png)
    
    
    In addition, a further plot is created showing the estimated abundances with related standard errors:
    
    ![Figure 4](Figure_4.png)
    
    Notice that the plots are both shown to the screen and saved as *.png files; see the reference manual for further information. 
    
    Alternatively, also the residuals can be looked at by specifying it in the "what" parameter:
    ```
    plot(fitted_abundances, what="residuals")
    ```
    This produces another series of plots, and the two of them related to the previous ones are the following:
    
    ![Figure 5](Figure_5.png)
    
    
    ![Figure 6](Figure_6.png)
    
    
3. The results can be saved to a *.csv file through the `save_labeling` function:
    ```
    save_labeling(fitted_abundances)
    ``` 
    
    The file is saved in the working directory, and for each sample it  reports:
    1. The estimated abundance of the labeling isotope;
    2. The related standard error from the fitting procedure;
    3. The percentage deviation between theoretical and experimental isotopic patterns;
    4. The outcome message from the fitting procedure. 